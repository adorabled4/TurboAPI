---
sidebar_position: 1
---

# ğŸ¥‘ AK/SKåŠ å¯†è¯´æ˜

åœ¨é€šè¿‡**email**è®¤è¯å¹¶ä¸”æˆåŠŸç”³è¯·AK/SKä¹‹å, æ‚¨å¯ä»¥é€šè¿‡è®¿é—®`http://turboapi.dhx.icu/`æ¥è°ƒç”¨æ¥å£æœåŠ¡ã€‚

## åŠ å¯†ç®—æ³•

- è®¿é—®æ§åˆ¶ï¼šAccessKeyï¼ˆè®¿é—®å¯†é’¥ï¼‰å’ŒSecretKeyï¼ˆç§˜é’¥ï¼‰æ˜¯ç”¨äºè®¿é—®è¿œç¨‹APIçš„èº«ä»½éªŒè¯å‡­è¯ã€‚
- éšæœºæ•°ï¼ˆNonceï¼‰ï¼šéšæœºæ•°ç”¨äºæ¯ä¸ªè¯·æ±‚ç”Ÿæˆä¸€ä¸ªå”¯ä¸€æ ‡è¯†ï¼Œä»¥ç¡®ä¿æ¯æ¬¡è¯·æ±‚çš„ç­¾åéƒ½æ˜¯ä¸åŒçš„ã€‚è¿™æœ‰åŠ©äºé˜²æ­¢é‡æ”¾æ”»å‡»ï¼Œå³æ”»å‡»è€…å°è¯•é‡å¤å‘é€å·²ç»æ•è·çš„è¯·æ±‚æˆ–ä¼ªé€ è¯·æ±‚ã€‚
- æ—¶é—´æˆ³ï¼ˆTimestampï¼‰ï¼šæ—¶é—´æˆ³ç”¨äºæ ‡è®°è¯·æ±‚å‘èµ·çš„æ—¶é—´ï¼Œè°ƒç”¨æœåŠ¡ç«¯çš„èº«ä»½éªŒè¯æ—¶ï¼Œå¯ä»¥ä½¿ç”¨æ—¶é—´æˆ³æ¥éªŒè¯æ­¤è¯·æ±‚æ˜¯å¦åœ¨æœ‰æ•ˆæ—¶é—´å†…å‘èµ·ã€‚å¯é˜²æ­¢é‡æ”¾æ”»å‡»å’Œæ—¶åºæ”»å‡»ã€‚
- ç”Ÿæˆç­¾åï¼šå°†è¯·æ±‚ä½“å†…å®¹ä¸SecretKeyè¿æ¥ï¼Œç„¶åå¯¹è¿æ¥åçš„å†…å®¹è¿›è¡ŒSHA256åŠ å¯†ï¼Œå¹¶ä»¥åå…­è¿›åˆ¶å­—ç¬¦ä¸²è¿”å›ç»“æœã€‚

ä¸‹é¢æ˜¯ä¸åŒç‰ˆæœ¬çš„åŠ å¯†ç®—æ³•å®ç°ç¤ºä¾‹:

### Javaç‰ˆæœ¬ğŸ¥

```java

public class Demo {

    private String accessKey = "YOUR ACCESS KEY";
    private String secretKey = "YOUR SECRET KEY";

    private void call() {
        String result = HttpRequest
                .get("http://turboapi.dhx.icu/api/v1/common/poet/random")
                .addHeaders(getHeaderMap())
                .execute().body();
    }

    private Map<String, String> getHeaderMap() {
        Map<String, String> hashMap = new HashMap<>();
        hashMap.put("accessKey", accessKey);
        hashMap.put("nonce", RandomUtil.randomNumbers(6));
        hashMap.put("timestamp", String.valueOf(System.currentTimeMillis() / 1000));
        hashMap.put("sign", genSign("", secretKey));
        return hashMap;
    }

    private String genSign(String body, String secretKey) {
        Digester md5 = new Digester(DigestAlgorithm.SHA256);
        String content = body + "." + secretKey;
        return md5.digestHex(content);
    }

}
```

### Python ç‰ˆæœ¬ğŸ¥¨

```python


import requests
import time
import hashlib
import random
from typing import Dict

class Demo:
    def __init__(self, access_key, secret_key):
        self.access_key = access_key
        self.secret_key = secret_key


        def call(self):
            headers = self._get_header_map()
            response = requests.get("http://turboapi.dhx.icu/api/v1/common/poet/random", headers=headers)
            result = response.text
            return result


        def _get_header_map(self) -> Dict[str, str]:
            header_map = {}
            header_map["accessKey"] = self.access_key
            header_map["nonce"] = ''.join(random.choices('0123456789', k=6))
            header_map["timestamp"] = str(int(time.time()))
            header_map["sign"] = self._gen_sign("", self.secret_key)
            return header_map


        def _gen_sign(self, body, secret_key):
            content = body + "." + secret_key
            return hashlib.sha256(content.encode('utf-8')).hexdigest()

```
### Golang ç‰ˆæœ¬ğŸ¥«

```Go 

package main

import (
    "fmt"
    "math/rand"
    "net/http"
    "strconv"
    "time"
)

type Demo struct {
    AccessKey string
    SecretKey string
}

func (d Demo) Call() string {
    headers := d.getHeaderMap()
    resp, _ := http.Get("http://turboapi.dhx.icu/api/v1/common/poet/random")
    defer resp.Body.Close()
    body, _ := io.ReadAll(resp.Body)
    return string(body)
}

func (d Demo) getHeaderMap() map[string]string {
    headerMap := make(map[string]string)
    headerMap["accessKey"] = d.AccessKey
    headerMap["nonce"] = strconv.Itoa(rand.Intn(1000000))
    headerMap["timestamp"] = strconv.Itoa(int32(time.Now().Unix()))
    headerMap["sign"] = genSign("", d.SecretKey)
    return headerMap
}

func genSign(body, secretKey string) string {
    content := body + "." + secretKey
    h := sha256.New()
    h.Write([]byte(content))
    return hex.EncodeToString(h.Sum(nil))
}




```

### JavaScript ç‰ˆæœ¬ğŸ§‚

```javascript

const fetch = require('node-fetch');
const crypto = require('crypto');

class Demo {
    constructor(accessKey, secretKey) {
        this.accessKey = accessKey;
        this.secretKey = secretKey;
    }

    async call() {
        const headers = this.getHeaderMap();
        const response = await fetch('http://turboapi.dhx.icu/api/v1/common/poet/random', {headers});
        const result = await response.text();
        return result;
    }

    getHeaderMap() {
        const headerMap = {};
        headerMap["accessKey"] = this.accessKey;
        headerMap["nonce"] = Math.floor(100000 + Math.random() * 900000);
        headerMap["timestamp"] = Math.floor(Date.now() / 1000);
        headerMap["sign"] = this.genSign("", this.secretKey);
        return headerMap;
    }

    genSign(body, secretKey) {
        const content = body + "." + secretKey;
        const hash = crypto.createHash('sha256');
        hash.update(content);
        return hash.digest('hex');
    }
}

```


## é‰´æƒå¤±è´¥è¯´æ˜

å¦‚æœé‰´æƒå¤±è´¥ï¼Œåˆ™æ ¹æ®ä¸åŒé”™è¯¯ç±»å‹è¿”å›ä¸åŒcodeçŠ¶æ€ç ï¼ŒåŒæ—¶æºå¸¦é”™è¯¯æè¿°ä¿¡æ¯ï¼Œè¯¦ç»†é”™è¯¯è¯´æ˜å¦‚ä¸‹ï¼š



| HTTP Code | è¯´æ˜                           | é”™è¯¯æè¿°ä¿¡æ¯                                                                                                               | è§£å†³æ–¹æ³•                                                                                                     |
| :-------- |:-----------------------------|:---------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------|
| 401       | ç¼ºå°‘å‚æ•°                         | `{"message":"Unauthorized"}`   | æ£€æŸ¥æ˜¯å¦åœ¨è¯·æ±‚ä¸­æ·»åŠ äº†keyä¿¡æ¯, å…·ä½“å‚è€ƒä¸Šé¢çš„**ç®—æ³•è¯´æ˜**ä»¥åŠ**ç¤ºä¾‹ä»£ç **                                                              |
| 401       | ç­¾åå‚æ•°è§£æå¤±è´¥                     | `{â€œmessageâ€:â€HMAC signature cannot be verifiedâ€}`  | æ£€æŸ¥ç­¾åçš„å„ä¸ªå‚æ•°æ˜¯å¦æœ‰ç¼ºå¤±æ˜¯å¦æ­£ç¡®ï¼Œç‰¹åˆ«ç¡®è®¤ä¸‹å¤åˆ¶çš„**AK/SK**æ˜¯å¦æ­£ç¡®                                                                 |
| 401       | ç­¾åæ ¡éªŒå¤±è´¥                       | `{â€œmessageâ€:â€HMAC signature does not matchâ€}` | ç­¾åéªŒè¯å¤±è´¥ï¼Œå¯èƒ½åŸå› æœ‰å¾ˆå¤šã€‚ 1. æ£€æŸ¥access_key,secret_keyæ˜¯å¦æ­£ç¡®ã€‚ 2.æ£€æŸ¥è®¡ç®—ç­¾åçš„å‚æ•°ï¼Œnonce , timestampæ˜¯å¦æŒ‰ç…§åè®®è¦æ±‚æ‹¼æ¥ã€‚ |
| 403       | æ—¶é’Ÿåç§»æ ¡éªŒå¤±è´¥                     | `{â€œmessageâ€:â€HMAC signature cannot be verified, a valid date or x-date header is required for HMAC Authenticationâ€}` | æ£€æŸ¥æœåŠ¡å™¨æ—¶é—´æ˜¯å¦æ ‡å‡†ï¼Œç›¸å·®5åˆ†é’Ÿä»¥ä¸Šä¼šæŠ¥æ­¤é”™è¯¯                                                                                 |
